#! /usr/bin/env python3

"""
Prints useful status information about Git repositories.
If the current directory is a Git repository, the status
of it is printed. If not, all directories one-level down
are checked and status information is printed for each.
"""

import os
import argparse
import subprocess
from contextlib import contextmanager


DEFAULT_LABEL = "bbrown"
DEFAULT_BRANCH_NAMES = ["master", "main", "develop", "development"]


def _pprint(text):
    if isinstance(text, str):
        print("\t%s" % text)
    elif isinstance(text, list):
        for line in text:
            print("\t\t%s" % line)


def _run_git_cmd(cmd, remove_text=None):
    output = subprocess.check_output(["git"] + cmd).decode()
    if remove_text:
        output = output.replace(remove_text, "")

    return [line.strip() for line in output.split("\n") if line]


def _get_git_branch():
    lines = _run_git_cmd(["rev-parse", "--abbrev-ref", "HEAD"])
    assert len(lines) == 1
    return lines[0]


def _get_git_branches():
    local_branches = _run_git_cmd(["branch"], remove_text="* ")
    return [branch for branch in local_branches if "detached" not in branch]


def _get_git_branches_with_label(label):
    all_branches = _run_git_cmd(["branch", "-a"], remove_text="* ")
    return [branch for branch in all_branches if label in branch]


def _get_git_status():
    return _run_git_cmd(["status", "-s"])


def _get_git_ignores():
    return _run_git_cmd(["clean", "-xdn"], remove_text="Would remove ")


def _get_git_stashes():
    return _run_git_cmd(["stash", "list"])


def _analyze_repo(label, verbose):
    branch = _get_git_branch()
    branches = _get_git_branches()
    label_branches = _get_git_branches_with_label(label)
    changes = _get_git_status()
    ignores = _get_git_ignores()
    stashes = _get_git_stashes()

    # Avoid duplication between ignores and changes
    untracked = [
        change.split()[1] for change in changes if change.split()[0] == "??"
    ]
    ignores = list(set(ignores) - set(untracked))

    def _status_checker(message, output_lines, cond=True):
        if cond and output_lines:
            _pprint(message)
            if verbose:
                _pprint(output_lines)

    if branch not in DEFAULT_BRANCH_NAMES:
        if branch == "HEAD":
            _pprint("In detached state.")
        else:
            _pprint("On feature branch %s." % _get_git_branch())

    _status_checker(
        "%d local branches in repository." % len(branches),
        branches,
        len(branches) > 1,
    )

    _status_checker(
        "%d branches contain label %s." % (len(label_branches), label),
        label_branches,
    )

    _status_checker("Repository has working changes.", changes)
    _status_checker("Repository has build artifacts.", ignores)
    _status_checker("Repository has stashed changes.", stashes)


@contextmanager
def _process_repo(repo):
    print(repo + ":")
    yield
    print()


@contextmanager
def _new_cwd(path):
    os.chdir(path)
    yield
    os.chdir("..")


def _is_git_repo(path):
    return os.path.isdir(path) and os.path.isdir(os.path.join(path, ".git"))


def check_repos(label=DEFAULT_LABEL, target_repo=None, verbose=False):
    cwd = os.getcwd()
    if _is_git_repo(cwd):
        repo = os.path.split(cwd)[-1]
        with _process_repo(repo):
            _analyze_repo(label, verbose)
    else:
        for repo in sorted(os.listdir(cwd)):
            if _is_git_repo(repo):
                if not target_repo or (target_repo and repo == target_repo):
                    with _process_repo(repo):
                        with _new_cwd(repo):
                            _analyze_repo(label, verbose)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)

    parser.add_argument(
        "-l",
        "--label",
        default=DEFAULT_LABEL,
        help="Label to use when searching for branches of interest.",
    )

    parser.add_argument(
        "-r",
        "--repository",
        help="Get status about a specific directory one-level down.",
    )

    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Print verbose output for repository state.",
    )

    args = parser.parse_args()

    check_repos(args.label, args.repository, args.verbose)
